package optim_storage_infrastructure;


import org.cloudbus.cloudsim.Cloudlet;
import org.cloudbus.cloudsim.CloudletSchedulerDynamicWorkload;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.Vm;

/**
 * This class calculate the CPU utilisation using the IoWokloadModel and VM CPU acapabilities 
 * @author hamza
 *
 */
public class IoCpuCorrelationModel {
	
	/**
	 * Gets the MI related to IO workload of a VM from  the hole Host 
	 * @param host the host
	 * @param vm 
	 * @return
	 */
	public double getCpuOfIofromHost (IoHost host, double time) {
		double cpuIoUtilization = 0.0;
		int mi = 0; 
		
		for (Vm vm : host.getVmList()) {
			IoVm tmpVm = (IoVm)vm;
			
			if (tmpVm.getRemainingVolume() > 0 ) {
				Storage tmpDevice = IoStorageList.getDeviceContainsVm(host.getStorageDevices(), tmpVm);
				
				if (tmpDevice instanceof IoHarddriveStorage) {
					IoHarddriveStorage hdd = (IoHarddriveStorage) tmpDevice;
					mi += getMiFromHdd(hdd, tmpVm, time);
					
				} else if (tmpDevice instanceof IoHarddriveStorage) {
					IoSolidStateStorage ssd = (IoSolidStateStorage) tmpDevice;
					mi += getMiFromSsd(ssd, tmpVm, time);
				}
				
			}
			
			// CPU Utilization compute
			// ioMips: the CPU performance to execute MI generated by IO
			double ioMips = mi / tmpVm.getSchedulingInterval();
			/*
			if ((tmpVm.getCurrentRequestedMips().get(0) + ioMips) <= vm.getHost().getAvailableMips()) {
				tmpVm.setCurrentAllocatedMips(Arrays.asList(tmpVm.getCurrentRequestedMips().get(0)+ioMips));
			}
			*/
			// The CPU utilization is the ratio between MIPS required by IO 
			// and MIPS offered by VM
			cpuIoUtilization = ioMips / tmpVm.getMips();
			
			// So update the CPU utilization of the cloudlet executed by this VM
			CloudletSchedulerDynamicWorkload scheduler = (CloudletSchedulerDynamicWorkload)vm.getCloudletScheduler();
			if (scheduler.getCloudletExecList().size() >= 1 ) {
				Cloudlet cloudlet = scheduler.getCloudletExecList().get(0).getCloudlet();
				IoUtilizationModelStochasticWithStorage utilModel = (IoUtilizationModelStochasticWithStorage)cloudlet.getUtilizationModelCpu();
				utilModel.setIoCpuUtilization(cpuIoUtilization);
				cloudlet.setCloudletLength(cloudlet.getCloudletLength()+mi);
				//Log.printLine("Hamza : Cloudlet has been alogate by "+mi+" MI");
				
			}
		}
		
		return cpuIoUtilization;
	}
	
	private int getMiFromHdd(IoHarddriveStorage hdd, IoVm vm, double time) {
		int mi = 0;
		double rrTime = 0.0;
		double srTime = 0.0;
		double rwTime = 0.0;
		double swTime = 0.0;
		
		// 1) Calculate MI for random read in HDD
		// CPU_Time(%) = 1% of IoTime
		rrTime = getRandReadTime(vm, hdd, time);
		mi += (int)Math.ceil((0.01 * rrTime) * vm.getMips());
		
		// 2) Calculate MI for sequential read in HDD
		// CPU_Time(%) = 9% of IoTime
		srTime = getSeqReadTime(vm, hdd, time);
		mi += (int)Math.ceil((0.09 * srTime) * vm.getMips());
		
		// 3) Calculate MI for random write in HDD
		// CPU_Time(%) = 0.000007 IoSize + 0.977947
		rwTime = getRandWriteTime(vm, hdd, time);
		mi += (int) Math.ceil((((0.000007 * vm.getIoWorkloadModel().getIoSize(time)) + 0.977947) / 100) * rwTime * vm.getMips());
		
		// 4) Calculate MI for sequential write in HDD
		// CPU_Time(%) = 0.000007 ioSize + 0.866556 
		swTime = getSeqWriteTime(vm, hdd, time);
		mi += (int) Math.ceil((((0.000007 * vm.getIoWorkloadModel().getIoSize(time)) + 0.866556) / 100) * swTime * vm.getMips());
		
		return mi;
	}
	
	private int getMiFromSsd(IoSolidStateStorage ssd, IoVm vm, double time) {
		int mi = 0;
		double rrTime = 0.0;
		double srTime = 0.0;
		double rwTime = 0.0;
		double swTime = 0.0;
		
		// 1) Calculate MI for random read in SSD
		// if IoSize <= 16KB CPU_Time(%) = 16% of IoTime
		// if IoSize >= 32KB CPU_Time(%) = 22% of IoTime
		rrTime = getRandReadTime(vm, ssd, time);
		if (vm.getIoWorkloadModel().getIoSize(time) <= 16384) {
			mi += (int)Math.ceil(0.16 * rrTime) * vm.getMips();
		} else {
			mi += (int)Math.ceil(0.22 * rrTime) * vm.getMips();
		}
		
		// 2) Calculate MI for sequential read in SSD
		// CPU_Time(%) = 36% of IoTime
		srTime = getSeqReadTime(vm, ssd, time);
		mi +=  (int)Math.ceil(0.36 * srTime) * vm.getMips();
				
		// 3) Calculate MI for random write in SSD
		// CPU_Time(%) = -0.000013 ioSize + 2.291483
		rwTime = getRandWriteTime(vm, ssd, time);
		mi += (int) Math.ceil((((-0.000013 * vm.getIoWorkloadModel().getIoSize(time)) + 2.291483) / 100) * rwTime) * vm.getMips();
				
		// 4) Calculate MI for sequential write in SSD
		// CPU_Time(%) = -0.000016 IoSize + 2.672552
		swTime = getSeqWriteTime(vm, ssd, time);
		mi += (int) Math.ceil((((-0.000016 * vm.getIoWorkloadModel().getIoSize(time)) + 2.672552) / 100) * swTime) * vm.getMips();
		
		return mi;
	}
	
	/**
	 * Gets the number of IOs during the scheduling intervall
	 * @param vm
	 * @return the number of IOs
	 */
	private int getIoNum (IoVm vm, double time) {
		int ioNum = 0;
		Double sched = new Double(vm.getSchedulingInterval());
		ioNum = vm.getIoWorkloadModel().getArrivalRate(time) * sched.intValue();
		return ioNum;
	}
	
	/**
	 * Gets the time to execute random read operations
	 * @param vm the VM
	 * @param device the storage device
	 * @return the random read time
	 */
	private double getRandReadTime (IoVm vm, Storage device, double time) {
		double ioTime = 0.0;
		
		ioTime = ((vm.getIoWorkloadModel().getRandomRate(time)*
				vm.getIoWorkloadModel().getReadRate(time)) * getIoNum(vm, time))	// Number of random read IOs
				/ device.getMaxIops();									// Get the time (#ios/iops)
		
		return ioTime;
	}
	
	/**
	 * Gets the time to execute sequential read operations
	 * @param vm the VM
	 * @param device the storage device
	 * @return the sequential read time
	 */
	private double getSeqReadTime (IoVm vm, Storage device, double time) {
		double ioTime = 0.0;
		
		ioTime = (((((1 - vm.getIoWorkloadModel().getRandomRate(time))*
				(vm.getIoWorkloadModel().getReadRate(time)) * getIoNum(vm, time))) 	// Number of sequential read IOs
				* vm.getIoWorkloadModel().getIoSize(time))			  			// size of sequential read operation (KB)
				/1048576)											  			// get the MB size					
				/ device.getMaxTransferRate();						  		// finally get the time (size(MB)/Throughput(MB/s))
		
		return ioTime;
	}
	
	/**
	 * Gets the time to execute random write operations
	 * @param vm the VM
	 * @param device the storage device
	 * @return the random write time
	 */
	private double getRandWriteTime (IoVm vm, Storage device, double time) {
		double ioTime = 0.0;
		
		ioTime = ((vm.getIoWorkloadModel().getRandomRate(time))*
				(1 - vm.getIoWorkloadModel().getReadRate(time)) * getIoNum(vm, time)) // Number of random read IOs
				/ device.getMaxIops(); 										// Get the time (#ios/iops)
		
		return ioTime;
	}
	
	/**
	 * Gets the time to execute sequential write operations
	 * @param vm the VM
	 * @param device the storage device
	 * @return the sequential write time
	 */
	private double getSeqWriteTime (IoVm vm, Storage device, double time) {
		double ioTime = 0.0;
		
		ioTime = (((((1 - vm.getIoWorkloadModel().getRandomRate(time))*
				 (1 - vm.getIoWorkloadModel().getReadRate(time))) 
				* getIoNum(vm, time)) 	// Number of sequential write IOs
				 * vm.getIoWorkloadModel().getIoSize(time))			  		// size of sequential read operation (KB)
				/1048576)											  		// get the MB size					
				/ device.getMaxTransferRate();							// finally get the time (size(MB)/Throughput(MB/s))
		
		return ioTime;
	}
}
